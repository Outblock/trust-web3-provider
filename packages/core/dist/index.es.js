import{EventEmitter as y}from"events";var h=(r,e,t)=>{if(!e.has(r))throw TypeError("Cannot "+t)},d=(r,e,t)=>(h(r,e,"read from private field"),t?t.call(r):e.get(r)),p=(r,e,t)=>{if(e.has(r))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(r):e.set(r,t)},u=(r,e,t,s)=>(h(r,e,"write to private field"),s?s.call(r,t):e.set(r,t),t),l,o;const n={PROMISES:"PROMISES",CALLBACK:"CALLBACK"},f=class{constructor(r){p(this,l,void 0),p(this,o,void 0),this.setStrategy(r)}static isCallbackAdapterRequest(r){return r.id!==void 0}setHandler(r){return u(this,o,r),this}request(r,e){if(!d(this,o))throw new Error("No handler defined for Adapter");return f.isCallbackAdapterRequest(r)?d(this,o).call(this,{network:e,id:r.id,name:r.method,params:r.params,object:r.params}):d(this,o).call(this,{name:r.method,network:e,params:r.params,object:r.params})}setStrategy(r){return u(this,l,r),this}getStrategy(){return d(this,l)}};let g=f;l=new WeakMap,o=new WeakMap;var A=Object.defineProperty,S=Object.defineProperties,k=Object.getOwnPropertyDescriptors,b=Object.getOwnPropertySymbols,C=Object.prototype.hasOwnProperty,E=Object.prototype.propertyIsEnumerable,w=(r,e,t)=>e in r?A(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,L=(r,e)=>{for(var t in e||(e={}))C.call(e,t)&&w(r,t,e[t]);if(b)for(var t of b(e))E.call(e,t)&&w(r,t,e[t]);return r},P=(r,e)=>S(r,k(e));class q extends g{constructor(){super(n.CALLBACK),this.callback=new Map}async request(e,t){return new Promise((s,v)=>{const c=new Date().getTime()+Math.floor(Math.random()*1e3);this.callback.set(c.toString(),{reject:v,resolve:s}),super.request(P(L({},e),{id:c}),t)})}sendResponse(e,t){if(this.callback.has(e.toString())){const s=this.callback.get(e.toString());this.callback.delete(e.toString()),s?.resolve(t)}else console.error(`Unable to find callback for requestId: ${e}`)}sendError(e,t){if(this.callback.has(e.toString())){const s=this.callback.get(e.toString());this.callback.delete(e.toString()),s?.reject(t)}else console.error(`Unable to find callback for requestId: ${e}`)}}class O extends g{constructor(){super(n.PROMISES)}request(e,t){return super.request(e,t)}}class R extends y{setAdapter(e){return this.adapter=e,this}async request(e){try{if(!this.adapter)throw new Error("No adapter set, maybe you forgot to register the provider?");const t=await this.adapter.request(e,this.getNetwork());return this.emit("onResponseReady",e,t),t}catch(t){throw t}}sendResponse(e,t){if(!this.adapter)throw new Error("Adapter not found");if(this.adapter.getStrategy()!==n.CALLBACK)throw new Error("Trying to send callback request on promisified adapter");this.adapter.sendResponse(e,t)}sendError(e,t){if(!this.adapter)throw new Error("Adapter not found");if(this.adapter.getStrategy()!==n.CALLBACK)throw new Error("Trying to send callback request on promisified adapter");this.adapter.sendError(e,t)}}var m=(r,e,t)=>{if(!e.has(r))throw TypeError("Cannot "+t)},i=(r,e,t)=>(m(r,e,"read from private field"),t?t.call(r):e.get(r)),j=(r,e,t)=>{if(e.has(r))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(r):e.set(r,t)},$=(r,e,t,s)=>(m(r,e,"write to private field"),s?s.call(r,t):e.set(r,t),t),a;class B{constructor(e){j(this,a,void 0);const t=e.strategy===n.CALLBACK?new q:new O;e.handler&&t.setHandler(e.handler),this.setAdapter(t)}setHandler(e){i(this,a).setHandler(e)}setAdapter(e){return $(this,a,e),this}registerProvider(e){return e.setAdapter(i(this,a)),this}registerProviders(e){return e.forEach(t=>this.registerProvider(t)),this}sendResponse(e,t){i(this,a).getStrategy()==="CALLBACK"&&i(this,a).sendResponse(e,t)}sendError(e,t){i(this,a).getStrategy()==="CALLBACK"&&i(this,a).sendError(e,t)}}a=new WeakMap;export{R as BaseProvider,B as Web3Provider};
//# sourceMappingURL=index.es.js.map
