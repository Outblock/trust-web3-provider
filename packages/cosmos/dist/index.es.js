import{BaseProvider as g}from"@trustwallet/web3-provider-core";class c{constructor(t){this.provider=t}async request(t,r){if(t.method==="getKey"){const i=await this.provider.internalRequest({method:"requestAccounts",params:t.params}),n=JSON.parse(i);return{algo:"secp256k1",address:n.address,bech32Address:n.address,pubKey:Buffer.from(n.pubKey,"hex")}}const s={signAmino:"signTransaction",signDirect:"signTransaction",signArbitrary:"signMessage",sendTx:"sendTransaction"};return s[t.method]?this.provider.internalRequest({method:s[t.method],params:t.params}):r()}}var d=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},h=(e,t,r)=>(d(e,t,"read from private field"),r?r.call(e):t.get(e)),f=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},l=(e,t,r,s)=>(d(e,t,"write to private field"),s?s.call(e,r):t.set(e,r),r),a;const o=class extends g{constructor(e){super(),f(this,a,!1),this.isKeplr=!0,this.isFlowWallet=!0,e&&(typeof e.disableMobileAdapter<"u"&&l(this,a,e.disableMobileAdapter),typeof e.isKeplr<"u"&&(this.isKeplr=e.isKeplr),typeof e.isFlowWallet<"u"&&(this.isFlowWallet=e.isFlowWallet)),h(this,a)||(this.mobileAdapter=new c(this))}static bufferToHex(e){return"0x"+Buffer.from(e).toString("hex")}getNetwork(){return o.NETWORK}isMobileAdapterEnabled(){return!h(this,a)}enable(e){return this.request({method:"enable",params:{chainIds:e}})}internalRequest(e){return super.request(e)}request(e){const t=()=>this.internalRequest(e);return this.mobileAdapter?this.mobileAdapter.request(e,t):t()}getKey(e){return this.request({method:"getKey",params:{chainId:e}})}async sendTx(e,t,r){const s=Buffer.from(t).toString("base64"),i=await this.request({method:"sendTx",params:{raw:s,chainId:e,mode:r}});return Buffer.from(i,"hex")}async signArbitrary(e,t,r){const s=Buffer.from(r),i=o.bufferToHex(s);return await this.request({method:"signArbitrary",params:{chainId:e,data:i,signerAddress:t}})}async signAmino(e,t,r){const s=await this.request({method:"signAmino",params:{chainId:e,sign_doc:r}}),{signed:i,signature:n}=JSON.parse(s);return{signed:i,signature:n}}async signDirect(e,t,r){const s={bodyBytes:o.bufferToHex(r.bodyBytes),authInfoBytes:o.bufferToHex(r.authInfoBytes)},i=await this.request({method:"signDirect",params:{signerAddress:t,chainId:e,sign_doc:s}}),{signature:n}=JSON.parse(i);return{signed:r,signature:n}}experimentalSuggestChain(){}getOfflineSignerDirect(e){return{getAccounts:async()=>[await this.getKey(e)],signDirect:async(t,r)=>{if(e!==r.chainId)throw new Error("Unmatched chain id with the offline signer");if((await this.getKey(r.chainId)).address!==t)throw new Error("Unknown signer address");return await this.signDirect(e,t,r)}}}getOfflineSigner(e){return this.getOfflineSignerAmino(e)}getOfflineSignerAuto(e){return this.getOfflineSignerAmino(e)}getOfflineSignerAmino(e){return{getAccounts:async()=>{const t=await this.getKey(e);return[{address:t.bech32Address,algo:"secp256k1",pubkey:t.pubKey}]},sign:(t,r)=>this.signAmino(e,t,r),signAmino:(t,r)=>this.signAmino(e,t,r)}}};let u=o;a=new WeakMap,u.NETWORK="cosmos";export{u as CosmosProvider};
//# sourceMappingURL=index.es.js.map
