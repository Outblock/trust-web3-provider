"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var E=require("@trustwallet/web3-provider-core"),m=require("@metamask/eth-sig-util");class b extends Error{constructor(t,r){super(),this.code=t,this.message=r}toString(){return`${this.message} (${this.code})`}}var M=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},A=(e,t,r)=>(M(e,t,"read from private field"),r?r.call(e):t.get(e)),W=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},v;const d=class{constructor(e){W(this,v,["eth_newFilter","eth_newBlockFilter","eth_newPendingTransactionFilter","eth_uninstallFilter","eth_subscribe"]),this.provider=e}static isUTF8(e){try{return new TextDecoder("utf8",{fatal:!0}).decode(e),!0}catch{return!1}}static bufferToHex(e){return"0x"+Buffer.from(e).toString("hex")}static messageToBuffer(e){let t=Buffer.from([]);try{typeof e=="string"?t=Buffer.from(e.replace("0x",""),"hex"):t=Buffer.from(e)}catch(r){console.log(`messageToBuffer error: ${r}`)}return t}async request(e){if(A(this,v).includes(e.method))return Promise.reject(new b(4200,`EthereumProvider does not support calling ${e.method}`));switch(e.method){case"wallet_requestPermissions":return this.provider.internalRequest({method:"wallet_requestPermissions",params:e.params});case"eth_requestAccounts":return this.provider.internalRequest({method:"requestAccounts",params:{}});case"eth_sign":return this.ethSign(e.params);case"personal_sign":return this.personalSign(e.params);case"personal_ecRecover":return this.personalECRecover(e.params);case"eth_signTypedData_v3":return this.ethSignTypedData(e.params,m.SignTypedDataVersion.V3);case"eth_signTypedData_v4":return this.ethSignTypedData(e.params,m.SignTypedDataVersion.V4);case"eth_signTypedData":return this.ethSignTypedData(e.params,m.SignTypedDataVersion.V1);case"eth_sendTransaction":return this.provider.internalRequest({method:"signTransaction",params:e.params[0]});case"wallet_watchAsset":{const{options:t,type:r}=e.params,{address:s,symbol:a,decimals:n}=t;return this.provider.internalRequest({method:"watchAsset",params:{type:r,contract:s,symbol:a,decimals:n||0}})}case"wallet_addEthereumChain":return this.provider.internalRequest({method:"addEthereumChain",params:e.params[0]});case"wallet_switchEthereumChain":return this.provider.internalRequest({method:"switchEthereumChain",params:e.params[0]});default:return(await this.provider.getRPC().call({method:e.method,jsonrpc:"2.0",params:e.params})).result}}personalECRecover(e){return this.provider.internalRequest({method:"ecRecover",params:{signature:e[1],message:e[0]}})}async personalSign(e){const[t]=await this.provider.request({method:"eth_accounts"});if(!t)throw new Error("Unable to execute personal_sign");let[r,s]=e;typeof r=="string"&&t.toLowerCase()===r.toLowerCase()&&(r=e[1],s=e[0]);const a=d.messageToBuffer(r);return this.provider.internalRequest({method:"signPersonalMessage",params:{data:a.length===0?d.bufferToHex(r):r,address:s}})}ethSign(e){if(!e)throw new Error("Missing params");const[t,r]=e,s=d.messageToBuffer(r),a=d.bufferToHex(s);return this.provider.internalRequest({method:d.isUTF8(s)?"signPersonalMessage":"signMessage",params:{data:a,address:t}})}async ethSignTypedData(e,t){const[r]=await this.provider.request({method:"eth_accounts"});if(!r)throw new Error("Unable to execute ethSignTypedData, address is not present");let[s,a]=e;typeof s=="string"&&r.toLowerCase()===s.toLowerCase()&&(s=e[1],a=e[0]);const n=typeof s=="string"?JSON.parse(s):s,{chainId:y}=n.domain||{};if(typeof y<"u"&&Number(y)!==Number(this.provider.getChainId()))throw new Error("Provided chainId does not match the currently active chain");const C=t!==m.SignTypedDataVersion.V1?m.TypedDataUtils.eip712Hash(n,t):"";return this.provider.internalRequest({method:"signTypedMessage",params:{data:"0x"+C.toString("hex"),raw:typeof s=="string"?s:JSON.stringify(s),address:a,version:t}})}};let $=d;v=new WeakMap;var j=Object.defineProperty,_=Object.getOwnPropertySymbols,B=Object.prototype.hasOwnProperty,D=Object.prototype.propertyIsEnumerable,q=(e,t,r)=>t in e?j(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,x=(e,t)=>{for(var r in t||(t={}))B.call(t,r)&&q(e,r,t[r]);if(_)for(var r of _(t))D.call(t,r)&&q(e,r,t[r]);return e},T=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},O=(e,t,r)=>(T(e,t,"read from private field"),r?r.call(e):t.get(e)),N=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},I=(e,t,r,s)=>(T(e,t,"write to private field"),s?s.call(e,r):t.set(e,r),r),w;class R{constructor(t){N(this,w,void 0),I(this,w,t)}async getBlockNumber(){return(await this.call({jsonrpc:"2.0",method:"eth_blockNumber",params:[]})).result}async getBlockByNumber(t){return(await this.call({jsonrpc:"2.0",method:"eth_getBlockByNumber",params:[t,!1]})).result}getFilterLogs(t){return this.call({jsonrpc:"2.0",method:"eth_getLogs",params:[t]})}async call(t){const r=await(await fetch(O(this,w),{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify(x({id:new Date().getTime()+Math.floor(Math.random()*1e3)},t))})).json();if(!r.result&&r.error)throw new Error(r.error.message||"rpc error");return r}}w=new WeakMap;var S=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},i=(e,t,r)=>(S(e,t,"read from private field"),r?r.call(e):t.get(e)),l=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},o=(e,t,r,s)=>(S(e,t,"write to private field"),s?s.call(e,r):t.set(e,r),r),h,u,g,f,c,p;const P=class extends E.BaseProvider{constructor(e){super(),l(this,h,void 0),l(this,u,void 0),l(this,g,!1),l(this,f,!1),l(this,c,void 0),l(this,p,void 0),this.isFlowWallet=!0,this.request=this.request.bind(this),e&&(e.chainId&&o(this,h,e.chainId),(e.rpc||e.rpcUrl)&&o(this,u,e.rpc||e.rpcUrl),typeof e.overwriteMetamask<"u"&&o(this,f,e.overwriteMetamask),typeof e.disableMobileAdapter<"u"&&o(this,g,e.disableMobileAdapter),typeof e.isFlowWallet<"u"&&(this.isFlowWallet=e.isFlowWallet),o(this,p,new R(i(this,u)))),i(this,g)||(this.mobileAdapter=new $(this)),super.on("onResponseReady",this.onResponseReady.bind(this)),this.connect()}connect(){this.emit("connect",{chainId:i(this,h)})}enable(){return this.request({method:"eth_requestAccounts"})}sendAsync(e,t){Array.isArray(e)?Promise.all(e.map(r=>this.request(r))).then(r=>t(null,r)).catch(r=>t(r,null)):this.request(e).then(r=>t(null,r)).catch(r=>t(r,null))}_send(e){const t={jsonrpc:"2.0",result:null};switch(e.method){case"eth_accounts":case"eth_coinbase":case"net_version":case"eth_chainId":t.result=this.handleStaticRequests({method:"eth_accounts"});break;default:throw new b(4200,`Trust does not support calling ${e.method} synchronously without a callback. Please provide a callback parameter to call ${e.method} asynchronously.`)}return t}send(e,t){if(typeof e=="string"&&(!t||Array.isArray(t))){const r=this;return new Promise((s,a)=>{try{const n=r.request({method:e,params:t});n instanceof Promise?n.then(s).catch(a):s(n)}catch(n){a(n)}})}else if(e&&typeof e=="object"&&typeof t=="function")return this.request(e).then(t);return this._send(e)}internalRequest(e){return super.request(e)}request(e){const t=()=>this.internalRequest(e);if(this.mobileAdapter){const r=this.handleStaticRequests(e,()=>this.mobileAdapter.request(e));return r instanceof Promise?r:Promise.resolve(r)}return this.handleStaticRequests(e,t)}handleStaticRequests(e,t){switch(e.method){case"net_version":return i(this,h)?parseInt(i(this,h)):void 0;case"eth_chainId":return i(this,h);case"eth_accounts":case"eth_coinbase":return i(this,c)?[i(this,c)]:[]}if(t)return t()}onResponseReady(e,t){var r,s,a,n;if(t)switch(e.method){case"eth_requestAccounts":case"requestAccounts":o(this,c,t[0]);break;case"wallet_requestPermissions":o(this,c,(n=(a=(s=(r=t[0])==null?void 0:r.caveats)==null?void 0:s[0])==null?void 0:a.value)==null?void 0:n[0]);break}}getNetwork(){return P.NETWORK}get connected(){return!0}get isMetaMask(){return i(this,f)}getChainId(){return i(this,h)}getNetworkVersion(){return this.handleStaticRequests({method:"net_version "})}setChainId(e){o(this,h,e)}setRPCUrl(e){o(this,u,e),o(this,p,new R(i(this,u)))}getRPC(){return i(this,p)}setOverwriteMetamask(e){o(this,f,e)}getAddress(){return i(this,c)}setAddress(e){o(this,c,e)}setRPC(e){o(this,p,e)}};let k=P;h=new WeakMap,u=new WeakMap,g=new WeakMap,f=new WeakMap,c=new WeakMap,p=new WeakMap,k.NETWORK="ethereum",exports.EthereumProvider=k;
//# sourceMappingURL=index.cjs.js.map
