import{BaseProvider as E}from"@trustwallet/web3-provider-core";import{SignTypedDataVersion as f,TypedDataUtils as M}from"@metamask/eth-sig-util";class b extends Error{constructor(t,r){super(),this.code=t,this.message=r}toString(){return`${this.message} (${this.code})`}}var A=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},W=(e,t,r)=>(A(e,t,"read from private field"),r?r.call(e):t.get(e)),$=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},v;const l=class{constructor(e){$(this,v,["eth_newFilter","eth_newBlockFilter","eth_newPendingTransactionFilter","eth_uninstallFilter","eth_subscribe"]),this.provider=e}static isUTF8(e){try{return new TextDecoder("utf8",{fatal:!0}).decode(e),!0}catch{return!1}}static bufferToHex(e){return"0x"+Buffer.from(e).toString("hex")}static messageToBuffer(e){let t=Buffer.from([]);try{typeof e=="string"?t=Buffer.from(e.replace("0x",""),"hex"):t=Buffer.from(e)}catch(r){console.log(`messageToBuffer error: ${r}`)}return t}async request(e){if(W(this,v).includes(e.method))return Promise.reject(new b(4200,`EthereumProvider does not support calling ${e.method}`));switch(e.method){case"wallet_requestPermissions":return this.provider.internalRequest({method:"wallet_requestPermissions",params:e.params});case"eth_requestAccounts":return this.provider.internalRequest({method:"requestAccounts",params:{}});case"eth_sign":return this.ethSign(e.params);case"personal_sign":return this.personalSign(e.params);case"personal_ecRecover":return this.personalECRecover(e.params);case"eth_signTypedData_v3":return this.ethSignTypedData(e.params,f.V3);case"eth_signTypedData_v4":return this.ethSignTypedData(e.params,f.V4);case"eth_signTypedData":return this.ethSignTypedData(e.params,f.V1);case"eth_sendTransaction":return this.provider.internalRequest({method:"signTransaction",params:e.params[0]});case"wallet_watchAsset":{const{options:t,type:r}=e.params,{address:s,symbol:a,decimals:n}=t;return this.provider.internalRequest({method:"watchAsset",params:{type:r,contract:s,symbol:a,decimals:n||0}})}case"wallet_addEthereumChain":return this.provider.internalRequest({method:"addEthereumChain",params:e.params[0]});case"wallet_switchEthereumChain":return this.provider.internalRequest({method:"switchEthereumChain",params:e.params[0]});default:return(await this.provider.getRPC().call({method:e.method,jsonrpc:"2.0",params:e.params})).result}}personalECRecover(e){return this.provider.internalRequest({method:"ecRecover",params:{signature:e[1],message:e[0]}})}async personalSign(e){const[t]=await this.provider.request({method:"eth_accounts"});if(!t)throw new Error("Unable to execute personal_sign");let[r,s]=e;typeof r=="string"&&t.toLowerCase()===r.toLowerCase()&&(r=e[1],s=e[0]);const a=l.messageToBuffer(r);return this.provider.internalRequest({method:"signPersonalMessage",params:{data:a.length===0?l.bufferToHex(r):r,address:s}})}ethSign(e){if(!e)throw new Error("Missing params");const[t,r]=e,s=l.messageToBuffer(r),a=l.bufferToHex(s);return this.provider.internalRequest({method:l.isUTF8(s)?"signPersonalMessage":"signMessage",params:{data:a,address:t}})}async ethSignTypedData(e,t){const[r]=await this.provider.request({method:"eth_accounts"});if(!r)throw new Error("Unable to execute ethSignTypedData, address is not present");let[s,a]=e;typeof s=="string"&&r.toLowerCase()===s.toLowerCase()&&(s=e[1],a=e[0]);const n=typeof s=="string"?JSON.parse(s):s,{chainId:y}=n.domain||{};if(typeof y<"u"&&Number(y)!==Number(this.provider.getChainId()))throw new Error("Provided chainId does not match the currently active chain");const C=t!==f.V1?M.eip712Hash(n,t):"";return this.provider.internalRequest({method:"signTypedMessage",params:{data:"0x"+C.toString("hex"),raw:typeof s=="string"?s:JSON.stringify(s),address:a,version:t}})}};let x=l;v=new WeakMap;var B=Object.defineProperty,_=Object.getOwnPropertySymbols,j=Object.prototype.hasOwnProperty,N=Object.prototype.propertyIsEnumerable,q=(e,t,r)=>t in e?B(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,O=(e,t)=>{for(var r in t||(t={}))j.call(t,r)&&q(e,r,t[r]);if(_)for(var r of _(t))N.call(t,r)&&q(e,r,t[r]);return e},R=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},D=(e,t,r)=>(R(e,t,"read from private field"),r?r.call(e):t.get(e)),I=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},F=(e,t,r,s)=>(R(e,t,"write to private field"),s?s.call(e,r):t.set(e,r),r),w;class T{constructor(t){I(this,w,void 0),F(this,w,t)}async getBlockNumber(){return(await this.call({jsonrpc:"2.0",method:"eth_blockNumber",params:[]})).result}async getBlockByNumber(t){return(await this.call({jsonrpc:"2.0",method:"eth_getBlockByNumber",params:[t,!1]})).result}getFilterLogs(t){return this.call({jsonrpc:"2.0",method:"eth_getLogs",params:[t]})}async call(t){const r=await(await fetch(D(this,w),{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify(O({id:new Date().getTime()+Math.floor(Math.random()*1e3)},t))})).json();if(!r.result&&r.error)throw new Error(r.error.message||"rpc error");return r}}w=new WeakMap;var k=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},i=(e,t,r)=>(k(e,t,"read from private field"),r?r.call(e):t.get(e)),d=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},o=(e,t,r,s)=>(k(e,t,"write to private field"),s?s.call(e,r):t.set(e,r),r),h,u,g,m,c,p;const P=class extends E{constructor(e){super(),d(this,h,void 0),d(this,u,void 0),d(this,g,!1),d(this,m,!1),d(this,c,void 0),d(this,p,void 0),this.isFlowWallet=!0,this.request=this.request.bind(this),e&&(e.chainId&&o(this,h,e.chainId),(e.rpc||e.rpcUrl)&&o(this,u,e.rpc||e.rpcUrl),typeof e.overwriteMetamask<"u"&&o(this,m,e.overwriteMetamask),typeof e.disableMobileAdapter<"u"&&o(this,g,e.disableMobileAdapter),typeof e.isFlowWallet<"u"&&(this.isFlowWallet=e.isFlowWallet),o(this,p,new T(i(this,u)))),i(this,g)||(this.mobileAdapter=new x(this)),super.on("onResponseReady",this.onResponseReady.bind(this)),this.connect()}connect(){this.emit("connect",{chainId:i(this,h)})}enable(){return this.request({method:"eth_requestAccounts"})}sendAsync(e,t){Array.isArray(e)?Promise.all(e.map(r=>this.request(r))).then(r=>t(null,r)).catch(r=>t(r,null)):this.request(e).then(r=>t(null,r)).catch(r=>t(r,null))}_send(e){const t={jsonrpc:"2.0",result:null};switch(e.method){case"eth_accounts":case"eth_coinbase":case"net_version":case"eth_chainId":t.result=this.handleStaticRequests({method:"eth_accounts"});break;default:throw new b(4200,`Trust does not support calling ${e.method} synchronously without a callback. Please provide a callback parameter to call ${e.method} asynchronously.`)}return t}send(e,t){if(typeof e=="string"&&(!t||Array.isArray(t))){const r=this;return new Promise((s,a)=>{try{const n=r.request({method:e,params:t});n instanceof Promise?n.then(s).catch(a):s(n)}catch(n){a(n)}})}else if(e&&typeof e=="object"&&typeof t=="function")return this.request(e).then(t);return this._send(e)}internalRequest(e){return super.request(e)}request(e){const t=()=>this.internalRequest(e);if(this.mobileAdapter){const r=this.handleStaticRequests(e,()=>this.mobileAdapter.request(e));return r instanceof Promise?r:Promise.resolve(r)}return this.handleStaticRequests(e,t)}handleStaticRequests(e,t){switch(e.method){case"net_version":return i(this,h)?parseInt(i(this,h)):void 0;case"eth_chainId":return i(this,h);case"eth_accounts":case"eth_coinbase":return i(this,c)?[i(this,c)]:[]}if(t)return t()}onResponseReady(e,t){var r,s,a,n;if(t)switch(e.method){case"eth_requestAccounts":case"requestAccounts":o(this,c,t[0]);break;case"wallet_requestPermissions":o(this,c,(n=(a=(s=(r=t[0])==null?void 0:r.caveats)==null?void 0:s[0])==null?void 0:a.value)==null?void 0:n[0]);break}}getNetwork(){return P.NETWORK}get connected(){return!0}get isMetaMask(){return i(this,m)}getChainId(){return i(this,h)}getNetworkVersion(){return this.handleStaticRequests({method:"net_version "})}setChainId(e){o(this,h,e)}setRPCUrl(e){o(this,u,e),o(this,p,new T(i(this,u)))}getRPC(){return i(this,p)}setOverwriteMetamask(e){o(this,m,e)}getAddress(){return i(this,c)}setAddress(e){o(this,c,e)}setRPC(e){o(this,p,e)}};let S=P;h=new WeakMap,u=new WeakMap,g=new WeakMap,m=new WeakMap,c=new WeakMap,p=new WeakMap,S.NETWORK="ethereum";export{S as EthereumProvider};
//# sourceMappingURL=index.es.js.map
