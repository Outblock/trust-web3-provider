"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var we=require("@trustwallet/web3-provider-core"),v=require("@solana/web3.js"),u=require("@solana/wallet-standard-features"),x=require("@wallet-standard/features"),me=require("bs58");function ve(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach(function(i){if(i!=="default"){var n=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(e,i,n.get?n:{enumerable:!0,get:function(){return t[i]}})}}),e.default=t,Object.freeze(e)}var L=ve(me),re=(t,e,i)=>{if(!e.has(t))throw TypeError("Cannot "+i)},ye=(t,e,i)=>(re(t,e,"read from private field"),i?i.call(t):e.get(t)),Me=(t,e,i)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,i)},be=(t,e,i,n)=>(re(t,e,"write to private field"),n?n.call(t,i):e.set(t,i),i),M;function Se(t){const e=({register:i})=>i(t);try{window.dispatchEvent(new Ie(e))}catch(i){console.error(`wallet-standard:register-wallet event could not be dispatched
`,i)}try{window.addEventListener("wallet-standard:app-ready",({detail:i})=>e(i))}catch(i){console.error(`wallet-standard:app-ready event listener could not be added
`,i)}}class Ie extends Event{constructor(e){super("wallet-standard:register-wallet",{bubbles:!1,cancelable:!1,composed:!1}),Me(this,M,void 0),be(this,M,e)}get detail(){return ye(this,M)}get type(){return"wallet-standard:register-wallet"}preventDefault(){throw new Error("preventDefault cannot be called")}stopImmediatePropagation(){throw new Error("stopImmediatePropagation cannot be called")}stopPropagation(){throw new Error("stopPropagation cannot be called")}}M=new WeakMap;function Te(t){Se(t.getInstanceWithAdapter())}const We="solana:mainnet",$=[We];function K(t){return $.includes(t)}function b(t){return"version"in t}var oe=(t,e,i)=>{if(!e.has(t))throw TypeError("Cannot "+i)},g=(t,e,i)=>(oe(t,e,"read from private field"),i?i.call(t):e.get(t)),p=(t,e,i)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,i)},f=(t,e,i,n)=>(oe(t,e,"write to private field"),n?n.call(t,i):e.set(t,i),i),S,I,T,W,A,N;const Ae=$,Ne=[u.SolanaSignAndSendTransaction,u.SolanaSignTransaction,u.SolanaSignMessage],ce=class{constructor({address:t,publicKey:e,label:i,icon:n}){p(this,S,void 0),p(this,I,void 0),p(this,T,void 0),p(this,W,void 0),p(this,A,void 0),p(this,N,void 0),new.target===ce&&Object.freeze(this),f(this,S,t),f(this,I,e),f(this,T,Ae),f(this,W,Ne),f(this,A,i),f(this,N,n)}get address(){return g(this,S)}get publicKey(){return g(this,I).slice()}get chains(){return g(this,T).slice()}get features(){return g(this,W).slice()}get label(){return g(this,A)}get icon(){return g(this,N)}};let ze=ce;S=new WeakMap,I=new WeakMap,T=new WeakMap,W=new WeakMap,A=new WeakMap,N=new WeakMap;const je="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTgiIGhlaWdodD0iNjUiIHZpZXdCb3g9IjAgMCA1OCA2NSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgOS4zODk0OUwyOC44OTA3IDBWNjUuMDA0MkM4LjI1NDUgNTYuMzM2OSAwIDM5LjcyNDggMCAzMC4zMzUzVjkuMzg5NDlaIiBmaWxsPSIjMDUwMEZGIi8+CjxwYXRoIGQ9Ik01Ny43ODIyIDkuMzg5NDlMMjguODkxNSAwVjY1LjAwNDJDNDkuNTI3NyA1Ni4zMzY5IDU3Ljc4MjIgMzkuNzI0OCA1Ny43ODIyIDMwLjMzNTNWOS4zODk0OVoiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8yMjAxXzY5NDIpIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIwMV82OTQyIiB4MT0iNTEuMzYxNSIgeTE9Ii00LjE1MjkzIiB4Mj0iMjkuNTM4NCIgeTI9IjY0LjUxNDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjAyMTEyIiBzdG9wLWNvbG9yPSIjMDAwMEZGIi8+CjxzdG9wIG9mZnNldD0iMC4wNzYyNDIzIiBzdG9wLWNvbG9yPSIjMDA5NEZGIi8+CjxzdG9wIG9mZnNldD0iMC4xNjMwODkiIHN0b3AtY29sb3I9IiM0OEZGOTEiLz4KPHN0b3Agb2Zmc2V0PSIwLjQyMDA0OSIgc3RvcC1jb2xvcj0iIzAwOTRGRiIvPgo8c3RvcCBvZmZzZXQ9IjAuNjgyODg2IiBzdG9wLWNvbG9yPSIjMDAzOEZGIi8+CjxzdG9wIG9mZnNldD0iMC45MDI0NjUiIHN0b3AtY29sb3I9IiMwNTAwRkYiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K";function ke(t,e){return Ee(t,e)}function Ee(t,e){if(t===e)return!0;const i=t.length;if(i!==e.length)return!1;for(let n=0;n<i;n++)if(t[n]!==e[n])return!1;return!0}var R=(t,e,i)=>{if(!e.has(t))throw TypeError("Cannot "+i)},a=(t,e,i)=>(R(t,e,"read from private field"),i?i.call(t):e.get(t)),o=(t,e,i)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,i)},q=(t,e,i,n)=>(R(t,e,"write to private field"),n?n.call(t,i):e.set(t,i),i),V=(t,e,i)=>(R(t,e,"access private method"),i),d,H,Y,_,l,h,U,z,F,J,le,w,j,X,Q,ee,k,te,E,ie;const De="trust:",he=class{constructor(t){o(this,z),o(this,J),o(this,d,{}),o(this,H,"1.0.0"),o(this,Y,"Trust"),o(this,_,je),o(this,l,null),o(this,h,void 0),o(this,U,(e,i)=>{var n;return(n=a(this,d)[e])!=null&&n.push(i)||(a(this,d)[e]=[i]),()=>V(this,J,le).call(this,e,i)}),o(this,w,()=>{var e;const i=(e=a(this,h).publicKey)==null?void 0:e.toBase58();if(i){const n=a(this,h).publicKey.toBytes(),s=a(this,l);(!s||s.address!==i||!ke(s.publicKey,n))&&(q(this,l,new ze({address:i,publicKey:n})),V(this,z,F).call(this,"change",{accounts:this.accounts}))}}),o(this,j,()=>{a(this,l)&&(q(this,l,null),V(this,z,F).call(this,"change",{accounts:this.accounts}))}),o(this,X,()=>{a(this,h).publicKey?a(this,w).call(this):a(this,j).call(this)}),o(this,Q,async({silent:e}={})=>(a(this,l)||await a(this,h).connect(e?{onlyIfTrusted:!0}:void 0),a(this,w).call(this),{accounts:this.accounts})),o(this,ee,async()=>{await a(this,h).disconnect()}),o(this,k,async(...e)=>{if(!a(this,l))throw new Error("not connected");const i=[];if(e.length===1){const{transaction:n,account:s,chain:c,options:r}=e[0],{minContextSlot:G,preflightCommitment:de,skipPreflight:ge,maxRetries:pe}=r||{};if(s!==a(this,l))throw new Error("invalid account");if(!K(c))throw new Error("invalid chain");const{signature:fe}=await a(this,h).signAndSendTransaction(v.VersionedTransaction.deserialize(n),{preflightCommitment:de,minContextSlot:G,maxRetries:pe,skipPreflight:ge});i.push({signature:L.decode(fe)})}else if(e.length>1)for(const n of e)i.push(...await a(this,k).call(this,n));return i}),o(this,te,async(...e)=>{if(!a(this,l))throw new Error("not connected");const i=[];if(e.length===1){const{transaction:n,account:s,chain:c}=e[0];if(s!==a(this,l))throw new Error("invalid account");if(c&&!K(c))throw new Error("invalid chain");const r=await a(this,h).signTransaction(v.VersionedTransaction.deserialize(n)),G=b(r)?r.serialize():new Uint8Array(r.serialize({requireAllSignatures:!1,verifySignatures:!1}));i.push({signedTransaction:G})}else if(e.length>1){let n;for(const r of e){if(r.account!==a(this,l))throw new Error("invalid account");if(r.chain){if(!K(r.chain))throw new Error("invalid chain");if(n){if(r.chain!==n)throw new Error("conflicting chain")}else n=r.chain}}const s=e.map(({transaction:r})=>v.VersionedTransaction.deserialize(r)),c=await a(this,h).signAllTransactions(s);i.push(...c.map(r=>({signedTransaction:b(r)?r.serialize():new Uint8Array(r.serialize({requireAllSignatures:!1,verifySignatures:!1}))})))}return i}),o(this,E,async(...e)=>{if(!a(this,l))throw new Error("not connected");const i=[];if(e.length===1){const{message:n,account:s}=e[0];if(s!==a(this,l))throw new Error("invalid account");const{signature:c}=await a(this,h).signMessage(n);i.push({signedMessage:n,signature:c})}else if(e.length>1)for(const n of e)i.push(...await a(this,E).call(this,n));return i}),o(this,ie,async(...e)=>{const i=[];if(e.length>1)for(const n of e)i.push(await a(this,h).signIn(n));else return[await a(this,h).signIn(e[0])];return i}),new.target===he&&Object.freeze(this),q(this,h,t),t.on("connect",a(this,w),this),t.on("disconnect",a(this,j),this),t.on("accountChanged",a(this,X),this),a(this,w).call(this)}get version(){return a(this,H)}get name(){return a(this,Y)}get icon(){return a(this,_)}get chains(){return $.slice()}get features(){return{[x.StandardConnect]:{version:"1.0.0",connect:a(this,Q)},[x.StandardDisconnect]:{version:"1.0.0",disconnect:a(this,ee)},[x.StandardEvents]:{version:"1.0.0",on:a(this,U)},[u.SolanaSignAndSendTransaction]:{version:"1.0.0",supportedTransactionVersions:["legacy",0],signAndSendTransaction:a(this,k)},[u.SolanaSignTransaction]:{version:"1.0.0",supportedTransactionVersions:["legacy",0],signTransaction:a(this,te)},[u.SolanaSignMessage]:{version:"1.0.0",signMessage:a(this,E)},[u.SolanaSignIn]:{version:"1.0.0",signIn:a(this,ie)},[De]:{trust:a(this,h)}}}get accounts(){return a(this,l)?[a(this,l)]:[]}};let Ce=he;d=new WeakMap,H=new WeakMap,Y=new WeakMap,_=new WeakMap,l=new WeakMap,h=new WeakMap,U=new WeakMap,z=new WeakSet,F=function(t,...e){var i;(i=a(this,d)[t])==null||i.forEach(n=>n.apply(null,e))},J=new WeakSet,le=function(t,e){var i;a(this,d)[t]=(i=a(this,d)[t])==null?void 0:i.filter(n=>e!==n)},w=new WeakMap,j=new WeakMap,X=new WeakMap,Q=new WeakMap,ee=new WeakMap,k=new WeakMap,te=new WeakMap,E=new WeakMap,ie=new WeakMap;class Oe{constructor(e,i=!1){this.useLegacySign=!1,this.provider=e,this.useLegacySign=i}async connect(e){const i=await this.provider.internalRequest({method:"requestAccounts",params:{options:e}});return this.provider.emit("connect"),{publicKey:new v.PublicKey(i[0])}}async signTransaction(e){if(this.useLegacySign)return await this.legacySign(e);const i=JSON.stringify(e);let n="legacy",s;b(e)?(n=e.version,s=Buffer.from(e.message.serialize()).toString("base64")):s=Buffer.from(e.serializeMessage()).toString("base64");const c=Buffer.from(e.serialize({requireAllSignatures:!1,verifySignatures:!1})).toString("base64"),r=await this.provider.internalRequest({method:"signRawTransaction",params:{data:i,raw:c,rawMessage:s,version:n}});return this.provider.mapSignedTransaction(e,r)}async legacySign(e){const i=JSON.stringify(e),n=typeof e.version!="number"?"legacy":e.version,s=L.encode(n==="legacy"?e.serializeMessage():n===0?e.message.serialize():e.serialize());try{const c=await this.provider.internalRequest({method:"signRawTransaction",params:{data:i,raw:s,version:n}});return this.provider.mapSignedTransaction(e,c)}catch(c){console.log(`<== Error: ${c}`)}}async request(e,i){var n;switch(e.method){case"signTransaction":return this.signTransaction(e.params);case"connect":return this.connect((n=e?.params)==null?void 0:n.options)}return i()}}var ne=(t,e,i)=>{if(!e.has(t))throw TypeError("Cannot "+i)},ae=(t,e,i)=>(ne(t,e,"read from private field"),i?i.call(t):e.get(t)),D=(t,e,i)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,i)},se=(t,e,i,n)=>(ne(t,e,"write to private field"),n?n.call(t,i):e.set(t,i),i),C=(t,e,i)=>(ne(t,e,"access private method"),i),O,P,Z,m,y;const B=class extends we.BaseProvider{constructor(t){super(),D(this,m),D(this,O,!1),D(this,P,!0),this.isFlowWallet=!0,D(this,Z,!1),t&&(typeof t.enableAdapter<"u"&&se(this,P,t.enableAdapter),typeof t.cluster<"u"&&(this.connection=new v.Connection(t.cluster,"confirmed")),typeof t.disableMobileAdapter<"u"&&se(this,O,t.disableMobileAdapter),typeof t.useLegacySign<"u"&&se(this,Z,t.useLegacySign),typeof t.isFlowWallet<"u"&&(this.isFlowWallet=t.isFlowWallet)),ae(this,P)&&Te(this),ae(this,O)||(this.mobileAdapter=new Oe(this,ae(this,Z)))}static bufferToHex(t){return"0x"+Buffer.from(t).toString("hex")}static messageToBuffer(t){let e=Buffer.from([]);try{typeof t=="string"?e=Buffer.from(t.replace("0x",""),"hex"):e=Buffer.from(t)}catch(i){console.log(`messageToBuffer error: ${i}`)}return e}getInstanceWithAdapter(){return new Ce(this)}async connect(t){const e=await C(this,m,y).call(this,{method:"connect",params:{options:t}});return this.publicKey=e.publicKey,e}disconnect(){return new Promise(t=>{this.publicKey=null,this.emit("disconnect"),t()})}async signAndSendTransaction(t,e){const i=await this.signTransaction(t);return{signature:await this.connection.sendRawTransaction(i.serialize(),e)}}signTransaction(t){return C(this,m,y).call(this,{method:"signTransaction",params:t})}signAllTransactions(t){return Promise.all(t.map(e=>this.signTransaction(e)))}async signRawTransactionMulti(t){return(await C(this,m,y).call(this,{method:"signRawTransactionMulti",params:{transactions:t.map(e=>{const i=JSON.stringify(e);let n="legacy",s;b(e)?(n=e.version,s=Buffer.from(e.message.serialize()).toString("base64")):s=Buffer.from(e.serializeMessage()).toString("base64");const c=Buffer.from(e.serialize({requireAllSignatures:!1,verifySignatures:!1})).toString("base64");return{data:i,raw:c,rawMessage:s,version:n}})}})).map((e,i)=>this.mapSignedTransaction(t[i],e))}async signMessage(t){var e;const i=B.bufferToHex(t),n=await C(this,m,y).call(this,{method:"signMessage",params:{data:i}});return{signature:Buffer.from(B.messageToBuffer(n).buffer),publicKey:(e=this.publicKey)==null?void 0:e.toBase58()}}signIn(t){throw new Error("Method not implemented.")}getNetwork(){return B.NETWORK}mapSignedTransaction(t,e){return t.addSignature(this.publicKey,L.decode(e)),t}request(t){throw new Error("Not implemented")}internalRequest(t){return super.request(t)}};let ue=B;O=new WeakMap,P=new WeakMap,Z=new WeakMap,m=new WeakSet,y=function(t){const e=()=>this.internalRequest(t);return this.mobileAdapter?this.mobileAdapter.request(t,e):e()},ue.NETWORK="solana",exports.SolanaProvider=ue;
//# sourceMappingURL=index.cjs.js.map
