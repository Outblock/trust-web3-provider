import{BaseProvider as me}from"@trustwallet/web3-provider-core";import{VersionedTransaction as G,PublicKey as ve,Connection as ye}from"@solana/web3.js";import{SolanaSignAndSendTransaction as ae,SolanaSignTransaction as se,SolanaSignMessage as re,SolanaSignIn as Me}from"@solana/wallet-standard-features";import{StandardConnect as be,StandardDisconnect as Ie,StandardEvents as Se}from"@wallet-standard/features";import*as x from"bs58";var oe=(t,e,i)=>{if(!e.has(t))throw TypeError("Cannot "+i)},Te=(t,e,i)=>(oe(t,e,"read from private field"),i?i.call(t):e.get(t)),We=(t,e,i)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,i)},Ae=(t,e,i,n)=>(oe(t,e,"write to private field"),n?n.call(t,i):e.set(t,i),i),v;function Ne(t){const e=({register:i})=>i(t);try{window.dispatchEvent(new ze(e))}catch(i){console.error(`wallet-standard:register-wallet event could not be dispatched
`,i)}try{window.addEventListener("wallet-standard:app-ready",({detail:i})=>e(i))}catch(i){console.error(`wallet-standard:app-ready event listener could not be added
`,i)}}class ze extends Event{constructor(e){super("wallet-standard:register-wallet",{bubbles:!1,cancelable:!1,composed:!1}),We(this,v,void 0),Ae(this,v,e)}get detail(){return Te(this,v)}get type(){return"wallet-standard:register-wallet"}preventDefault(){throw new Error("preventDefault cannot be called")}stopImmediatePropagation(){throw new Error("stopImmediatePropagation cannot be called")}stopPropagation(){throw new Error("stopPropagation cannot be called")}}v=new WeakMap;function ke(t){Ne(t.getInstanceWithAdapter())}const Ee="solana:mainnet",P=[Ee];function L(t){return P.includes(t)}function y(t){return"version"in t}var ce=(t,e,i)=>{if(!e.has(t))throw TypeError("Cannot "+i)},d=(t,e,i)=>(ce(t,e,"read from private field"),i?i.call(t):e.get(t)),g=(t,e,i)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,i)},p=(t,e,i,n)=>(ce(t,e,"write to private field"),n?n.call(t,i):e.set(t,i),i),M,b,I,S,T,W;const je=P,De=[ae,se,re],le=class{constructor({address:t,publicKey:e,label:i,icon:n}){g(this,M,void 0),g(this,b,void 0),g(this,I,void 0),g(this,S,void 0),g(this,T,void 0),g(this,W,void 0),new.target===le&&Object.freeze(this),p(this,M,t),p(this,b,e),p(this,I,je),p(this,S,De),p(this,T,i),p(this,W,n)}get address(){return d(this,M)}get publicKey(){return d(this,b).slice()}get chains(){return d(this,I).slice()}get features(){return d(this,S).slice()}get label(){return d(this,T)}get icon(){return d(this,W)}};let Ce=le;M=new WeakMap,b=new WeakMap,I=new WeakMap,S=new WeakMap,T=new WeakMap,W=new WeakMap;const Oe="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTgiIGhlaWdodD0iNjUiIHZpZXdCb3g9IjAgMCA1OCA2NSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgOS4zODk0OUwyOC44OTA3IDBWNjUuMDA0MkM4LjI1NDUgNTYuMzM2OSAwIDM5LjcyNDggMCAzMC4zMzUzVjkuMzg5NDlaIiBmaWxsPSIjMDUwMEZGIi8+CjxwYXRoIGQ9Ik01Ny43ODIyIDkuMzg5NDlMMjguODkxNSAwVjY1LjAwNDJDNDkuNTI3NyA1Ni4zMzY5IDU3Ljc4MjIgMzkuNzI0OCA1Ny43ODIyIDMwLjMzNTNWOS4zODk0OVoiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8yMjAxXzY5NDIpIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIwMV82OTQyIiB4MT0iNTEuMzYxNSIgeTE9Ii00LjE1MjkzIiB4Mj0iMjkuNTM4NCIgeTI9IjY0LjUxNDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjAyMTEyIiBzdG9wLWNvbG9yPSIjMDAwMEZGIi8+CjxzdG9wIG9mZnNldD0iMC4wNzYyNDIzIiBzdG9wLWNvbG9yPSIjMDA5NEZGIi8+CjxzdG9wIG9mZnNldD0iMC4xNjMwODkiIHN0b3AtY29sb3I9IiM0OEZGOTEiLz4KPHN0b3Agb2Zmc2V0PSIwLjQyMDA0OSIgc3RvcC1jb2xvcj0iIzAwOTRGRiIvPgo8c3RvcCBvZmZzZXQ9IjAuNjgyODg2IiBzdG9wLWNvbG9yPSIjMDAzOEZGIi8+CjxzdG9wIG9mZnNldD0iMC45MDI0NjUiIHN0b3AtY29sb3I9IiMwNTAwRkYiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K";function Ze(t,e){return Be(t,e)}function Be(t,e){if(t===e)return!0;const i=t.length;if(i!==e.length)return!1;for(let n=0;n<i;n++)if(t[n]!==e[n])return!1;return!0}var $=(t,e,i)=>{if(!e.has(t))throw TypeError("Cannot "+i)},a=(t,e,i)=>($(t,e,"read from private field"),i?i.call(t):e.get(t)),o=(t,e,i)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,i)},K=(t,e,i,n)=>($(t,e,"write to private field"),n?n.call(t,i):e.set(t,i),i),R=(t,e,i)=>($(t,e,"access private method"),i),u,q,V,H,l,h,Y,A,U,F,he,w,N,J,X,Q,z,_,k,ee;const Ge="trust:",ue=class{constructor(t){o(this,A),o(this,F),o(this,u,{}),o(this,q,"1.0.0"),o(this,V,"Trust"),o(this,H,Oe),o(this,l,null),o(this,h,void 0),o(this,Y,(e,i)=>{var n;return(n=a(this,u)[e])!=null&&n.push(i)||(a(this,u)[e]=[i]),()=>R(this,F,he).call(this,e,i)}),o(this,w,()=>{var e;const i=(e=a(this,h).publicKey)==null?void 0:e.toBase58();if(i){const n=a(this,h).publicKey.toBytes(),s=a(this,l);(!s||s.address!==i||!Ze(s.publicKey,n))&&(K(this,l,new Ce({address:i,publicKey:n})),R(this,A,U).call(this,"change",{accounts:this.accounts}))}}),o(this,N,()=>{a(this,l)&&(K(this,l,null),R(this,A,U).call(this,"change",{accounts:this.accounts}))}),o(this,J,()=>{a(this,h).publicKey?a(this,w).call(this):a(this,N).call(this)}),o(this,X,async({silent:e}={})=>(a(this,l)||await a(this,h).connect(e?{onlyIfTrusted:!0}:void 0),a(this,w).call(this),{accounts:this.accounts})),o(this,Q,async()=>{await a(this,h).disconnect()}),o(this,z,async(...e)=>{if(!a(this,l))throw new Error("not connected");const i=[];if(e.length===1){const{transaction:n,account:s,chain:c,options:r}=e[0],{minContextSlot:B,preflightCommitment:ge,skipPreflight:pe,maxRetries:we}=r||{};if(s!==a(this,l))throw new Error("invalid account");if(!L(c))throw new Error("invalid chain");const{signature:fe}=await a(this,h).signAndSendTransaction(G.deserialize(n),{preflightCommitment:ge,minContextSlot:B,maxRetries:we,skipPreflight:pe});i.push({signature:x.decode(fe)})}else if(e.length>1)for(const n of e)i.push(...await a(this,z).call(this,n));return i}),o(this,_,async(...e)=>{if(!a(this,l))throw new Error("not connected");const i=[];if(e.length===1){const{transaction:n,account:s,chain:c}=e[0];if(s!==a(this,l))throw new Error("invalid account");if(c&&!L(c))throw new Error("invalid chain");const r=await a(this,h).signTransaction(G.deserialize(n)),B=y(r)?r.serialize():new Uint8Array(r.serialize({requireAllSignatures:!1,verifySignatures:!1}));i.push({signedTransaction:B})}else if(e.length>1){let n;for(const r of e){if(r.account!==a(this,l))throw new Error("invalid account");if(r.chain){if(!L(r.chain))throw new Error("invalid chain");if(n){if(r.chain!==n)throw new Error("conflicting chain")}else n=r.chain}}const s=e.map(({transaction:r})=>G.deserialize(r)),c=await a(this,h).signAllTransactions(s);i.push(...c.map(r=>({signedTransaction:y(r)?r.serialize():new Uint8Array(r.serialize({requireAllSignatures:!1,verifySignatures:!1}))})))}return i}),o(this,k,async(...e)=>{if(!a(this,l))throw new Error("not connected");const i=[];if(e.length===1){const{message:n,account:s}=e[0];if(s!==a(this,l))throw new Error("invalid account");const{signature:c}=await a(this,h).signMessage(n);i.push({signedMessage:n,signature:c})}else if(e.length>1)for(const n of e)i.push(...await a(this,k).call(this,n));return i}),o(this,ee,async(...e)=>{const i=[];if(e.length>1)for(const n of e)i.push(await a(this,h).signIn(n));else return[await a(this,h).signIn(e[0])];return i}),new.target===ue&&Object.freeze(this),K(this,h,t),t.on("connect",a(this,w),this),t.on("disconnect",a(this,N),this),t.on("accountChanged",a(this,J),this),a(this,w).call(this)}get version(){return a(this,q)}get name(){return a(this,V)}get icon(){return a(this,H)}get chains(){return P.slice()}get features(){return{[be]:{version:"1.0.0",connect:a(this,X)},[Ie]:{version:"1.0.0",disconnect:a(this,Q)},[Se]:{version:"1.0.0",on:a(this,Y)},[ae]:{version:"1.0.0",supportedTransactionVersions:["legacy",0],signAndSendTransaction:a(this,z)},[se]:{version:"1.0.0",supportedTransactionVersions:["legacy",0],signTransaction:a(this,_)},[re]:{version:"1.0.0",signMessage:a(this,k)},[Me]:{version:"1.0.0",signIn:a(this,ee)},[Ge]:{trust:a(this,h)}}}get accounts(){return a(this,l)?[a(this,l)]:[]}};let xe=ue;u=new WeakMap,q=new WeakMap,V=new WeakMap,H=new WeakMap,l=new WeakMap,h=new WeakMap,Y=new WeakMap,A=new WeakSet,U=function(t,...e){var i;(i=a(this,u)[t])==null||i.forEach(n=>n.apply(null,e))},F=new WeakSet,he=function(t,e){var i;a(this,u)[t]=(i=a(this,u)[t])==null?void 0:i.filter(n=>e!==n)},w=new WeakMap,N=new WeakMap,J=new WeakMap,X=new WeakMap,Q=new WeakMap,z=new WeakMap,_=new WeakMap,k=new WeakMap,ee=new WeakMap;class Pe{constructor(e,i=!1){this.useLegacySign=!1,this.provider=e,this.useLegacySign=i}async connect(e){const i=await this.provider.internalRequest({method:"requestAccounts",params:{options:e}});return this.provider.emit("connect"),{publicKey:new ve(i[0])}}async signTransaction(e){if(this.useLegacySign)return await this.legacySign(e);const i=JSON.stringify(e);let n="legacy",s;y(e)?(n=e.version,s=Buffer.from(e.message.serialize()).toString("base64")):s=Buffer.from(e.serializeMessage()).toString("base64");const c=Buffer.from(e.serialize({requireAllSignatures:!1,verifySignatures:!1})).toString("base64"),r=await this.provider.internalRequest({method:"signRawTransaction",params:{data:i,raw:c,rawMessage:s,version:n}});return this.provider.mapSignedTransaction(e,r)}async legacySign(e){const i=JSON.stringify(e),n=typeof e.version!="number"?"legacy":e.version,s=x.encode(n==="legacy"?e.serializeMessage():n===0?e.message.serialize():e.serialize());try{const c=await this.provider.internalRequest({method:"signRawTransaction",params:{data:i,raw:s,version:n}});return this.provider.mapSignedTransaction(e,c)}catch(c){console.log(`<== Error: ${c}`)}}async request(e,i){var n;switch(e.method){case"signTransaction":return this.signTransaction(e.params);case"connect":return this.connect((n=e?.params)==null?void 0:n.options)}return i()}}var te=(t,e,i)=>{if(!e.has(t))throw TypeError("Cannot "+i)},ie=(t,e,i)=>(te(t,e,"read from private field"),i?i.call(t):e.get(t)),E=(t,e,i)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,i)},ne=(t,e,i,n)=>(te(t,e,"write to private field"),n?n.call(t,i):e.set(t,i),i),j=(t,e,i)=>(te(t,e,"access private method"),i),D,C,O,f,m;const Z=class extends me{constructor(t){super(),E(this,f),E(this,D,!1),E(this,C,!0),this.isFlowWallet=!0,E(this,O,!1),t&&(typeof t.enableAdapter<"u"&&ne(this,C,t.enableAdapter),typeof t.cluster<"u"&&(this.connection=new ye(t.cluster,"confirmed")),typeof t.disableMobileAdapter<"u"&&ne(this,D,t.disableMobileAdapter),typeof t.useLegacySign<"u"&&ne(this,O,t.useLegacySign),typeof t.isFlowWallet<"u"&&(this.isFlowWallet=t.isFlowWallet)),ie(this,C)&&ke(this),ie(this,D)||(this.mobileAdapter=new Pe(this,ie(this,O)))}static bufferToHex(t){return"0x"+Buffer.from(t).toString("hex")}static messageToBuffer(t){let e=Buffer.from([]);try{typeof t=="string"?e=Buffer.from(t.replace("0x",""),"hex"):e=Buffer.from(t)}catch(i){console.log(`messageToBuffer error: ${i}`)}return e}getInstanceWithAdapter(){return new xe(this)}async connect(t){const e=await j(this,f,m).call(this,{method:"connect",params:{options:t}});return this.publicKey=e.publicKey,e}disconnect(){return new Promise(t=>{this.publicKey=null,this.emit("disconnect"),t()})}async signAndSendTransaction(t,e){const i=await this.signTransaction(t);return{signature:await this.connection.sendRawTransaction(i.serialize(),e)}}signTransaction(t){return j(this,f,m).call(this,{method:"signTransaction",params:t})}signAllTransactions(t){return Promise.all(t.map(e=>this.signTransaction(e)))}async signRawTransactionMulti(t){return(await j(this,f,m).call(this,{method:"signRawTransactionMulti",params:{transactions:t.map(e=>{const i=JSON.stringify(e);let n="legacy",s;y(e)?(n=e.version,s=Buffer.from(e.message.serialize()).toString("base64")):s=Buffer.from(e.serializeMessage()).toString("base64");const c=Buffer.from(e.serialize({requireAllSignatures:!1,verifySignatures:!1})).toString("base64");return{data:i,raw:c,rawMessage:s,version:n}})}})).map((e,i)=>this.mapSignedTransaction(t[i],e))}async signMessage(t){var e;const i=Z.bufferToHex(t),n=await j(this,f,m).call(this,{method:"signMessage",params:{data:i}});return{signature:Buffer.from(Z.messageToBuffer(n).buffer),publicKey:(e=this.publicKey)==null?void 0:e.toBase58()}}signIn(t){throw new Error("Method not implemented.")}getNetwork(){return Z.NETWORK}mapSignedTransaction(t,e){return t.addSignature(this.publicKey,x.decode(e)),t}request(t){throw new Error("Not implemented")}internalRequest(t){return super.request(t)}};let de=Z;D=new WeakMap,C=new WeakMap,O=new WeakMap,f=new WeakSet,m=function(t){const e=()=>this.internalRequest(t);return this.mobileAdapter?this.mobileAdapter.request(t,e):e()},de.NETWORK="solana";export{de as SolanaProvider};
//# sourceMappingURL=index.es.js.map
